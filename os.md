# OS
## 进程和线程

进程，进程就是正在执行程序代码的实时结果，他具有一个或多个内存映射的内存地址空间，也可能包括一个或多个线程
 
线程，线程是进程中活动的对象，每个线程都有独立的程序计数器，进程栈和进程寄存器，内核调度对象是线程而不是进程。在Unix系统里，一个进程包含一个线程，现在的系统一个进程会包含多个线程。对Linux而言，线程是一种特殊的进程，不做特殊区分。
 
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。
一个程序至少有一个进程，一个进程至少有一个线程; 线程影响进程，进程调用线程。
进程是系统资源分配的最小单位，线程是程序执行的最小单位。
进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响；
线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间；一个线程死掉就等于整个进程死掉（因为线程共享地址空间），所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
 
简而言之,一个程序至少有一个进程,一个进程至少有一个线程。

2.线程的划分尺度小于进程，使得多线程程序的并发性高。
3.另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
4.线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
5.从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
 
 
## 进程线程优缺点
线程执行开销小，但不利于资源的管理和保护；
而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移
根据进程与线程的设置，操作系统大致分为如下类型：
(1) 单进程、单线程，MS-DOS大致是这种操作系统；
(2) 多进程、单线程，多数UNIX(及类UNIX的LINUX)是这种操作系统；
(3) 多进程、多线程，Win32(Windows NT/2000/XP等)、Solaris 2.x和OS/2都是这种操作系统；
(4) 单进程、多线程，VxWorks是这种操作系统。
 
## Linux 内存
malloc和new申请的都是虚拟内存
malloc函数的实质，有一个将可用的内存块连接起来的链表，调用malloc的时候，会沿着链表找一个满足用户需求的内存块。然后将这个内存块一分为二，一块和用户所申请的内存大小相同，另一块返回到链表中。如果用户申请一个大的内存块，空闲链表上可能没有可以满足用户要求的片段，这个时候malloc函数就会请求延时，对链表上的内存进行整理。如果还是不可以的话， 内存申请失败，返回NULL。
new的话，底层实现还是malloc，在分配失败的时候会抛出bad_alloc类型的异常
 
与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。
 
目前支持I/O多路复用的系统调用有 select，pselect，poll，epoll，I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，pselect，poll，epoll本质上都是同步I/O
 
 
Linux中，调用fork()系统创建进程，调用fork()的进程是父进程，新产生的进程是子进程，调用结束时，在返回到这个相同位置上，父进程恢复执行，子进程开始执行，fork()系统调用从内核返回两次，一次回到父进程，一次回到新产生的子进程
 
Exec()可以传进新的地址空间，把新的程序加载其中，调用exit()退出执行，会释放资源，父进程通过wait4()系统调用来查询子进程是否终结
 
进程列表存放在任务队列的双向循环列表，每一项类型都是task_struct。内核通过PID来标示进程，最大默认值32768
 
 
写时拷贝。传统的Fork()系统调用直接把所有资源复制给新创建的进程，这种实现过于简单且效率低下，因为拷贝数据不共享，Linux的fork()使用写时拷贝，可以推迟甚至免除拷贝，内核不复制整个进程的地址空间，而是让父进程和子进程共享同一个拷贝，需要写入的时候，数据才会被复制，在此之前都是以只读形式共享
 
Linux通过clone()来实现fork()
Vfork()除了不拷贝父进程的页表，其他功能相同
 
## 进程间通信
常见的通信方式：
1. 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
2. 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
4. 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
5. 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
6. 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
7. 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
8. 信号 ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
